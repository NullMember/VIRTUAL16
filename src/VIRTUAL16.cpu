; Copyright (c) 2020 Malik Enes Åžafak
;
; Permission is hereby granted, free of charge, to any person obtaining
; a copy of this software and associated documentation files (the
; "Software"), to deal in the Software without restriction, including
; without limitation the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the Software, and to
; permit persons to whom the Software is furnished to do so, subject to
; the following conditions:
;
; The above copyright notice and this permission notice shall be
; included in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

#cpudef
{
    #bits 8
	
	#tokendef reg
    {
        R0 = 0
        R1 = 1
        R2 = 2
        R3 = 3
        R4 = 4
        R5 = 5
        R6 = 6
        R7 = 7
        R8 = 8
        R9 = 9
        R10 = 10
        R11 = 11
        R12 = 12
        R13 = 13
        R14 = 14
        R15 = 15
        ML = 11
        MH = 12
        CR = 13
        SR = 14
        PC = 15
    }
	
	RET								-> 0x00
	MOV  {src: reg}, {dst: reg}		-> 0x01 @ src[3:0] @ dst[3:0]
	MOV  @{src: reg}, {dst: reg}	-> 0x02 @ src[3:0] @ dst[3:0]
	MOV	 {src: reg}, @{dst: reg}	-> 0x03 @ src[3:0] @ dst[3:0]
	MOV  +@{src: reg}, {dst: reg}	-> 0x04 @ src[3:0] @ dst[3:0]
	MOV  {src: reg}, +@{dst: reg}	-> 0x05 @ src[3:0] @ dst[3:0]
	MOV  {src: reg}.H, {dst: reg}.H	-> 0x06 @ src[3:0] @ dst[3:0]
	MOV  {src: reg}.H, {dst: reg}.L	-> 0x07 @ src[3:0] @ dst[3:0]
	MOV  {src: reg}.L, {dst: reg}.H	-> 0x08 @ src[3:0] @ dst[3:0]
	MOV  {src: reg}.L, {dst: reg}.L	-> 0x09 @ src[3:0] @ dst[3:0]
	SWAP {src: reg}, {dst: reg} 	-> 0x0A @ src[3:0] @ dst[3:0]
	SWAP {reg: reg}		 			-> 0x0A @ reg[3:0] @ reg[3:0]
	JSR	 {label}					-> 0x0B @ label[7:0] @ label[15:8]
	NJSR {label}					-> 0x0C @ label[7:0] @ label[15:8]
	JMPR {reg: reg}					-> 0x0D @ reg[3:0] @ 15[3:0]
	JMP	 {label}					-> 0x0E @ label[7:0] @ label[15:8]
	RTS								-> 0x0F

	INC  {dst: reg}, #{count}		-> 0x10 @ dst[3:0] @ count[3:0]
	INC  {dst: reg}					-> 0x10 @ dst[3:0] @ 0[3:0]
	DEC  {dst: reg}, #{count}		-> 0x11 @ dst[3:0] @ count[3:0]
	DEC  {dst: reg}					-> 0x11 @ dst[3:0] @ 0[3:0]
	ADD  {dst: reg}, {src: reg}		-> 0x12 @ dst[3:0] @ src[3:0]
	ADC  {dst: reg}, {src: reg}		-> 0x13 @ dst[3:0] @ src[3:0]
	SUB  {dst: reg}, {src: reg}		-> 0x14 @ dst[3:0] @ src[3:0]
	SBC  {dst: reg}, {src: reg}		-> 0x15 @ dst[3:0] @ src[3:0]
	SMUL {dst: reg}, {src: reg}		-> 0x16 @ dst[3:0] @ src[3:0]
	UMUL {dst: reg}, {src: reg}		-> 0x17 @ dst[3:0] @ src[3:0]
	CMP  {dst: reg}, {src: reg}		-> 0x18 @ dst[3:0] @ src[3:0]
	ASR  {dst: reg}, #{count}		-> 0x19 @ dst[3:0] @ count[3:0]
	ASR  {dst: reg}					-> 0x19 @ dst[3:0] @ 0[3:0]
	LSL  {dst: reg}, #{count}		-> 0x1A @ dst[3:0] @ count[3:0]
	LSL  {dst: reg}					-> 0x1A @ dst[3:0] @ 0[3:0]
	LSR  {dst: reg}, #{count}		-> 0x1B @ dst[3:0] @ count[3:0]
	LSR  {dst: reg}					-> 0x1B @ dst[3:0] @ 0[3:0]
	ROL  {dst: reg}, #{count}		-> 0x1C @ dst[3:0] @ count[3:0]
	ROL  {dst: reg}					-> 0x1C @ dst[3:0] @ 0[3:0]
	RLC  {dst: reg}, #{count}		-> 0x1D @ dst[3:0] @ count[3:0]
	RLC  {dst: reg}					-> 0x1D @ dst[3:0] @ 0[3:0]
	ROR  {dst: reg}, #{count}		-> 0x1E @ dst[3:0] @ count[3:0]
	ROR  {dst: reg}					-> 0x1E @ dst[3:0] @ 0[3:0]
	RRC  {dst: reg}, #{count}		-> 0x1F @ dst[3:0] @ count[3:0]
	RRC  {dst: reg}					-> 0x1F @ dst[3:0] @ 0[3:0]

	BCC	{label}						->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0x20 @ reladdr[7:0]
	}
	BCS	{label}						->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0x21 @ reladdr[7:0]
	}
	BRA	{label}						->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0x22 @ reladdr[7:0]
	}
	AND  {src: reg}, {dst: reg}		-> 0x23 @ src[3:0] @ dst[3:0]
	OR   {src: reg}, {dst: reg}		-> 0x24 @ src[3:0] @ dst[3:0]
	XOR  {src: reg}, {dst: reg}		-> 0x25 @ src[3:0] @ dst[3:0]
	CLC								-> 0x26
	SEC								-> 0x27
	PUSH {reg: reg}					-> 0x28 @ reg[3:0] @ 0[3:0]
	POP  {reg: reg}					-> 0x29 @ reg[3:0] @ 0[3:0]

	MOV  #{value}, {dst: reg}.L		-> 0x5	@ dst[3:0] @ value[7:0]
	MOV  #{value}, {dst: reg}.H		-> 0x6	@ dst[3:0] @ value[7:0]
	MOV  #{value}, {dst: reg}		-> 0x7	@ dst[3:0] @ value[7:0] @ value[15:8]
	MOV	 {label}, {reg: reg}		-> 0x8  @ reg[3:0] @ label[7:0] @ label[15:8]
	MOV	 {reg: reg}, {label}		-> 0x9  @ reg[3:0] @ label[7:0] @ label[15:8]
	BNM1 {dst: reg}, {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xA @ dst[3:0] @ reladdr[7:0]
	}
	BM1	 {dst: reg}, {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xB @ dst[3:0] @ reladdr[7:0]
	}
	BMI	 {dst: reg}, {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xC @ dst[3:0] @ reladdr[7:0]
	}
	BPL	 {dst: reg}, {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xD @ dst[3:0] @ reladdr[7:0]
	}
	BNE	 {dst: reg}, {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xE @ dst[3:0] @ reladdr[7:0]
	}
	BEQ	 {dst: reg}, {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xF @ dst[3:0] @ reladdr[7:0]
	}
	BNM1 {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xAD @ reladdr[7:0]
	}
	BM1	 {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xBD @ reladdr[7:0]
	}
	BMI	 {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xCD @ reladdr[7:0]
	}
	BPL	 {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xDD @ reladdr[7:0]
	}
	BNE	 {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xED @ reladdr[7:0]
	}
	BEQ	 {label}		->
	{
		reladdr = label - pc - 2
		assert(reladdr <=  0x7f)
		assert(reladdr >= !0x7f)
		0xFD @ reladdr[7:0]
	}
}

;Write your code below here

MAIN:

LOOP:

END:
	RET